{
  "kind": "implementation_plan",
  "version": "1.0",
  "title": "Fix login functionality in end-to-end flow",
  "requirements": [
    {
      "id": "REQ-10",
      "summary": "Debug and fix Internet Identity login flow in extension content script to enable successful authentication",
      "acceptanceCriteria": [
        "Users can click the login button in the DogOverlay and successfully authenticate with Internet Identity",
        "After successful login, the authenticated principal is available to the actor hooks",
        "The InternetIdentityProvider context properly initializes in the shadow DOM content script environment",
        "Login state persists across page reloads within the extension",
        "Error handling displays clear feedback if login fails"
      ],
      "file_operations": [
        {
          "path": "frontend/src/content/content.tsx",
          "operation": "modify",
          "description": "Debug and fix the InternetIdentityProvider initialization in the shadow DOM content script environment. Ensure the provider correctly handles the extension context, including proper canister ID configuration and auth-client initialization. Add error boundaries and console logging to diagnose initialization failures. Verify that the QueryClient and provider wrapping order supports authentication state propagation to child components."
        },
        {
          "path": "frontend/src/content/DogOverlay.tsx",
          "operation": "modify",
          "description": "Debug the login button handler to ensure it properly triggers Internet Identity authentication in the extension content script context. Add error handling with user-facing feedback for login failures. Verify that the useInternetIdentity hook returns valid login/logout functions and isAuthenticated state. Add loading states during authentication. Ensure the component re-renders appropriately after successful login to show authenticated UI elements."
        }
      ]
    },
    {
      "id": "REQ-11",
      "summary": "Verify authenticated users can perform CRUD operations on notes through NotesPanel",
      "acceptanceCriteria": [
        "After login, users can create new notes that persist to the backend",
        "Users can view their existing notes loaded from the backend",
        "Users can edit existing notes and changes save successfully",
        "Users can delete notes and the deletion reflects in the backend",
        "All CRUD operations complete without errors and update the UI appropriately"
      ],
      "file_operations": [
        {
          "path": "frontend/src/content/NotesPanel.tsx",
          "operation": "modify",
          "description": "Debug and verify all CRUD operations work correctly after successful login. Add error handling for each operation (create, edit, delete) with user-facing error messages. Ensure the useNotes query properly refetches after mutations. Add loading states for async operations. Verify that the actor is properly passed to all mutation hooks. Add console logging to diagnose any failures in note operations. Ensure the UI updates immediately after successful operations via React Query invalidation."
        },
        {
          "path": "frontend/src/hooks/useQueries.ts",
          "operation": "modify",
          "description": "Debug the notes-related React Query hooks (useNotes, useCreateNote, useEditNote, useDeleteNote) to ensure they work correctly with the authenticated actor. Add error handling and retry logic. Verify that mutations properly invalidate the notes query to trigger refetches. Add logging to diagnose actor availability issues. Ensure query keys are consistent and cache invalidation works as expected after mutations."
        }
      ]
    },
    {
      "id": "REQ-12",
      "summary": "Verify authenticated users can set break reminders and receive notifications",
      "acceptanceCriteria": [
        "After login, users can set break reminder intervals that save to the backend",
        "Break notifications appear at the configured intervals",
        "Users can snooze or dismiss notifications",
        "Break reminder settings persist across sessions",
        "The notification queue properly manages pending notifications"
      ],
      "file_operations": [
        {
          "path": "frontend/src/content/BreakReminderPanel.tsx",
          "operation": "modify",
          "description": "Debug the break reminder interval setting to ensure it saves correctly to the backend after login. Add error handling for the useSetBreakReminder mutation with user-facing feedback. Verify that the interval value is properly converted to the backend's expected bigint format. Add success confirmation feedback after saving. Ensure localStorage and backend state remain synchronized."
        },
        {
          "path": "frontend/src/content/DogOverlay.tsx",
          "operation": "modify",
          "description": "Debug the notification polling mechanism to ensure it works correctly with the authenticated actor. Verify the useEffect that checks for notifications via getNextNotification properly triggers at configured intervals. Add error handling for notification fetching. Ensure the BreakNotification component displays when a notification is available. Verify that snooze and dismiss actions properly clear notifications and reset timers. Add logging to diagnose notification queue management issues."
        },
        {
          "path": "frontend/src/hooks/useQueries.ts",
          "operation": "modify",
          "description": "Debug the useSetBreakReminder and useGetNextNotification hooks to ensure they work correctly with the authenticated actor. Add error handling and logging. Verify that the break reminder mutation properly calls the backend setBreakReminder method with the correct bigint parameter. Ensure the notification query properly handles null responses and error states."
        }
      ]
    }
  ]
}